\documentclass[12pt]{memoir}
\usepackage{common}

\addbibresource{references}

\title{}
\author{Andrew Head}

\begin{document}

\definition{Title}{Building Context-Relevant, Summative Forms of Programming Documentation for Opportunistic Development}

\definition{Author}{Andrew Head, PhD Student, UC Berkeley}

This work aims to develop and understand context-relevant, summative, and rapid-access forms of programming documentation designed to fit fast-paced opportunistic programming practice.
The goal of this work is to enable end user programmers to develop more efficiently and effectively.
This relates to the NSF broader impact of \textbf{increasing and improving public engagement with science and technology}.

\section{Background}

Clarke introduced the persona of an \emph{opportunistic developer} to describe the software developer who develops just enough of an understanding of a technology to solve a business problem~\cite{clarke_what_2007}.
Recent studies have observed opportunistic behavior for programmers beyond business, including creative workers~\cite{brandt_opportunistic_2008} and web designers~\cite{dorn_learning_2010}.
While this style of development enables rapid results~\cite{brandt_opportunistic_2008}, it comes with hazards:
functionality is copied and pasted from online examples, with less attention to explanations~\cite{brandt_two_2009};
code may be written in a sub-optimal way in order to maintain flow and move on to other tasks~\cite{brandt_opportunistic_2008}.
% programmers are more likely to re-implement functionality instead of reusing established systems and libraries~\cite{brandt_opportunistic_2008};

Past observation confirms that the cards are stacked against typical programming documentation for maintaining the attention of those developing opportunistically.
In human-computer interaction, Carroll writes how users learning new technologies are often too busy learning to make use of instruction~\cite{carroll_nurnberg_1990}.
For end user programmers (those programming for personal purposes~\cite{ko_state_2011}), Blackwell's Attention Investment models how programmers carefully weigh the costs of engineering activities against perceived benefits~\cite{blackwell_psychological_2006}.
Good software engineering practice, like understanding the model of an API, often loses to expediency.

When a programmer's focus centers on trial and error with code instead of making sense of comprehensive references, we face two tasks to better support the opportunistic developer in understanding found code.
First, \textbf{relevant documentation should be moved from hidden locations to the code examples they arre used in.}
Second, \textbf{documentation should be provided in a context-relevant, easy-to-read, short form.}

Meanwhile, a growing corpus of online high-quality ``crowd documentation''~\cite{parnin_crowd_2012} provides new environments in which to support context-relevant documentation and new resources to mine and serve to information seekers in a context-relevant form.

\section{Proposed Research}

I hypothesize that new techniques for delivering context-relevant, summative documentation will help opportunistic developers in two ways:
\begin{itemize}[noitemsep,topsep=0pt]
\item By decreasing verbosity and increasing relevance, it will enable programmers to gain the same understanding of libraries with less effort
\item When presented next to code examples, it can lesson the effort required to develop solutions involving unfamiliar software
\end{itemize}

I propose three systems to demonstrate the potential of context-relevant, summative programming documentation.
The \textbf{intellectual merit} of the first of these systems has already been recognized:
the Tutorons work has received an Honorable Mention VL/HCC~\cite{head_tutorons_2015}, a main conference on end user programming.
Prototypes for the other systems two have been built.
They must undergo substantial further development and evaluation.

\subsection{Tutorons}
% Context-relevant descriptions of online code found during opportunistic information seeking.
Programmers often encounter syntax that they don't understand in web tutorials that has not been explained by the tutorial author.
A Tutoron is a routine on a public server that can detect code snippets in the markup for tutorial pages, and synthesize English prose, diagrams, and usage examples to describe this code.
When a programmer navigates in a browser instrumented with the Tutorons plugin, programmers can view context-relevant explanations of high-level intent of code and its low level syntax for snippets automatically detected by the server.
Tutorons were implemented for three languages commonly embedded in tutorials: the wget Unix command line, CSS selectors, and regular expressions.
An initial in-lab usability study has shown that such adaptive explanations can reduce accesses to external documentation on the Web (Fisher's exact test, $n$ = 9, $p<.01$).

\subsection{StackSkim}
Often, there are many tutorials that can satisfy a programmer's information need, but the first one programmers find is not sufficient.
StackSkim is a visual search interface for exploring, comparing, and selecting code from large collections of similar examples, providing a front-end to millions of questions from StackOverflow, a popular programming Q\&A.
The system has yet to be applied to be comprehensively evaluated, and we seek to address two challenges:
(1) building algorithms and visual affordances to detect and highlight differences between snippets serving the same purpose
(2) interleaving examples with production code mined from Github to reveal common exception cases that occur in practice.
% It enables programmers to detect the most popular classes and programming structures used in collections of dozens of related answers to their questions, and locate examples with either minimal or elaborate accompanying explanation.
% A preliminary usability study revealed positive qualitative feedback, 
% The primary technical contribution for both of these steps will revolve around comparison of pre-parsed code examples from the relatively clean repositories of example and production code on StackOverflow and Github, respectively.

\subsection{CodeConverter}
When developing opportunistically, programmers rely on known languages to get work done~\cite{brandt_opportunistic_2008}.
To reduce the barrier of working with unfamiliar languages within the same domain, we propose an experimental system called CodeConverter.
When learning a new language, programmers will write simple statements of a familiar language, and expand them to see the semantic equivalent in the target language.
With CodeConverter, a new language's syntax will be described through the translations that appear---relevant descriptions will be provided as comments accompanying expansions instead of as a tutorial with a preset path.
For feasibility, first studies will focus only on rule-based translation of small statements for restricted problem sets, rather than using machine translation (e.g.,~\cite{karaivanov_phrase-based_2014}).
% The eventual evaluation will focus on having programmers from a local hackerspace develop code for an embedded platform with an unfamiliar language but with familiar tasks.

Evaluation of each of these systems will include mixed methods.
Success of the tools in reducing programming effort will be measured by, for instance, task completion rates and reference to external documentation for in-lab usability studies with programmers.
Qualitative feedback will be collected from all studies to refine our understanding of programmer information seeking challenges and our systems' affordances.
The result will be a set of software artifacts to new programmer workflows for making use of documentation during opportunistic development.

\if 0
\begin{figure}%
  \centering
  \parbox{.45\textwidth}{%
    \includegraphics[width=\linewidth]{figures/tutorons_microexplanation}
    \caption{%
      A micro-explanation for a command line generated by a Tutoron with multiple levels of detail 
      (definition, high-level intent, arguments)
    }\label{fig:tutorons_microexplanation}
  }%
  \qquad
  \parbox{.45\textwidth}{%
    \includegraphics[width=\linewidth]{figures/stackskim_ui}
    \caption{%
      StackSkim, a visual interface for comparing and noticing trends in large collections of code examples that solve the same problem.
    }\label{fig:stackskim_ui}
  }
\end{figure}
\fi

\if 0
Point out the number of non-professional programmers.
Also point out crises in developing technologies that are caused by programmers who followed non-systematic practices

This work can be seen as an effort to reconcile the best practices of the ``systematic developer'' with recent tendencies of ``opportunistic'' programming habits.
\textbf{I could add in a mention of Blackwell's Attention Investment model here to mention why it is that programmers may program opportunistically, and why we should and how we can vary incentives and costs.}
Clarke introduced the persona of an \emph{opportunistic developer} to describe a software developer who writes code in an ``exploratory fashion'' and develops a ``sufficient understanding of a technology to understand how it can solve a business problem''.
(This contrasts with the \emph{systematic developer}, who writes code defensively and ``develops a deep understanding of a technology before using it''~\cite{clarke_what_2007}.)
In their study of exhibit designers at San Francisco's Exploratorium interactive science museum, Brandt et al.\ reported on a group who engaged in \emph{opportunistic programming} who weren't professional developers~\cite{brandt_opportunistic_2008} but were very much what might be considered as end-user programmers --- those developing code for personal rather than public use~\cite{ko_state_2011}.

Brandt et al.\ associated several habits with opportunistic programming that are counter to what we would hope for students working with code or end-users developing a better understanding of code.
Those programming opportunistically likely to incorporate functionality by copying and pasting code, often from online sources~\cite{brandt_two_2009}.
They are more likely to implement functionality from scratch for well-known libraries, instead of reusing existing systems and libraries~\cite{brandt_opportunistic_2008}.
They also practice ``code satisficing'', implementing functionality in a sub-optimal way in order to maintain flow and move on to other functionality~\cite{brandt_opportunistic_2008}.

While opportunistic programming is powerful in that it allows one to rapidly prototype and ideate and that it reduces the cycle time of editing and debugging code~\cite{brandt_opportunistic_2008}, this behavior discourages the formation of new mental models and an introduction to new tools that should be encouraged for both novice programmers and many end-user programmers.
The author of this proposal observed much of what would be called ``opportunistic'' habits while instructing a user interface design course.
After providing reference code to students for programming interfaces on Android phones and smartwatches, he helped students debug problems related to API reuse and the side effects of mixed code from multiple examples after hearing students self-report to having ``copied and pasted'' code from online tutorials and the slides he distributed.
In light of a prevalence of the ease of opportunistic habits and programmers' ability to copy-and-paste code from an increasingly comprehensive body of crowd documentation online~\cite{parnin_crowd_2012}, I define the goals of my research:

\emph{In my research, I develop and study software artifacts to support systematic inspection of found code from information interfaces programmers use when developing opportunistically.}

The theoretical deliverables of this work is establishing how systematic habits amidst opportunistic practice will improve:
(\emph{a}) programmers' mental models of reused code, libraries and tools used they develop
(\emph{b}) enable more accurate feasibility assessments of upcoming tasks (for example, see~\cite{ko_role_2011})
(\emph{c}) reduce design barriers~\cite{ko_six_2004} when planning new functionality

The artifacts that I develop belong to two themes:
\begin{itemize}[noitemsep]
\item Techniques for automatically generating instructive explanations and demonstrations of found code
\item Interfaces for critical inspection of alternatives when selecting code for reuse
\end{itemize}

I have developed the artifacts that enable exploration within both of these themes, and have published a first paper on the one of the two themes.
Toward the first, a paper I presented at VL/HCC explored techniques for automatically augmenting code in online examples with natural languages explanations and demonstrations of code.\footnote{%
The Tutorons system was implemented as both a browser plugin and a standalone JavaScript library, and can be viewed in action on \url{www.tutorons.com}.
}
We put forward a set of four guidelines to inspire the development of context-sensitive help:
(\emph{a}) leverage multiple representations to illuminate high-level intent and enable low-level understanding of syntax
(\emph{b}) be concise --- skip static explanations and focus on dynamically generated content
(\emph{c}) reappropriate existing documentation
(\emph{d}) inspect code examples on a large scale to support explanations of common usage.
In a nine-participant user study, the system was shown to reduce the number of accesses to external documentation needed to modify online code to perform new tasks.
\textbf{Next steps will include \ldots}
\textbf{Mention the theories used: MLT, layered documentation, Attention Investment}

Towards the second goal, I and co-developer have built a visual search interface for StackOverflow, a popular online programming Q\&A.
In response to Brandt et al.'s recommendations to develop tools that support ``comparing, reasoning about, integrating, and modifying found code''~\cite{brandt_opportunistic_2008}, we developed StackSkim, \emph{a visual search interface for exploring answers to StackOverflow questions that have a multitude of answers}.
The interface offers rapid visual inspection of frequent libraries used for addressing the searcher's programming problem;
through direct manipulation, users can also rapidly collect and compare similar code snippets.
\textbf{Next steps will include \ldots}

Each of these efforts relies on the cultivation of new software artifacts to aid programmers in understanding code during an opportunistic programming task.
Each has already followed and will continue to follow a mixed methods approach of observation and controlled experiments to determine how these tools indeed alter not only the task of opportunistic programming, but also programmers' behavior in selecting, understanding, and using code found online.
We are currently developing a version of Tutorons explanations that we hope will be incorporated into an introductory CS classroom's online textbook to better understand the role of automatic explanations of code for novice programmers.
\textbf{Add some note here about how we intend to run some workshop on clean code reuse habits.}
\fi

\section{References}
\printbibliography[heading=none]

\end{document}
