\documentclass[12pt]{memoir}
\usepackage{common}

\addbibresource{references}

\title{}
\author{Andrew Head}

\begin{document}

\definition{Title}{Building Context-Relevant, Summative Forms of Programming Documentation for Opportunistic Development}

\definition{Author}{Andrew Head, PhD Student, UC Berkeley}

This work aims to develop and understand context-relevant, summative, and rapid-access forms of programming documentation designed to fit fast-paced opportunistic programming practice.
The goal of this work is to enable end user programmers to develop more efficiently and effectively.
This relates to the NSF broader impact of \textbf{increasing and improving public engagement with science and technology}.

\section{Background}

Clarke~\cite{clarke_what_2007} introduced the persona of an \emph{opportunistic developer} to describe the software developer who develops just enough of an understanding of a technology to solve a business problem.
Recent studies have observed opportunistic behavior for programmers beyond business, including creative workers~\cite{brandt_opportunistic_2008} and web designers~\cite{dorn_learning_2010}.
While this style of development enables rapid results~\cite{brandt_opportunistic_2008}, it comes with hazards:
functionality is copied and pasted from online examples, with less attention to explanations~\cite{brandt_two_2009};
code may be written in a sub-optimal way in order to maintain flow and move on to other tasks~\cite{brandt_opportunistic_2008}.
% programmers are more likely to re-implement functionality instead of reusing established systems and libraries~\cite{brandt_opportunistic_2008};

Past observation confirms that the cards are stacked against typical programming documentation for maintaining the attention of those developing opportunistically.
In human-computer interaction, Carroll writes how users learning new technologies are often too busy learning to make use of instruction~\cite{carroll_nurnberg_1990}.
For end user programmers (those programming for personal purposes~\cite{ko_state_2011}), Blackwell's Attention Investment models how programmers carefully weigh the costs of engineering activities against perceived benefits~\cite{blackwell_psychological_2006}.
Good software engineering practice like understanding mental models of APIs often lose in this assessment.

When programmers' focus centers on trial and error with code instead of comprehensive references, we are faced with two tasks to better support opportunistic developers in understanding found code.
First, \textbf{relevant documentation should be moved from hidden locations on the web to the code examples they're using.}
Second, \textbf{documentation should be provided in a context-relevant, easy-to-read, short form.}

Amidst this milieu, a growing corpus of online high-quality ``crowd documentation''~\cite{parnin_crowd_2012} provides new environments in which to support context-relevant documentation and new resources to mine and serve to information seekers in a context-relevant form.

\section{Proposed Research}

I hypothesize that new techniques for delivering context-relevant, summative documentation will help opportunistic developers in these two ways:
\begin{itemize}[noitemsep,topsep=0pt]
\item by decreasing verbosity and increased relevance, it will enable programmers to gain the same understanding of libraries in less time
\item when presented by the code example, it can lesson the effort required to develop solutions involving unfamiliar software
\end{itemize}

I propose three systems to explore and demonstrate the potential of context-relevant, summative programming documentation for opportunistic development.
The first of these systems has already been built and results presented with an Honorable Mention VL/HCC~\cite{head_tutorons_2015}, a main conference on end user programming.
Prototype for the other two have been built.
They must undergo substantial further development and evaluation.

\subsection{Tutorons}
% Context-relevant descriptions of online code found during opportunistic information seeking.
Programmers often encounter syntax that they don't understand in web tutorials that has not been explained by the tutorial author.
A Tutoron is a routine on a public server that can detect code snippets in the markup for tutorial pages, and synthesize English prose, diagrams, and usage examples to describe this code.
When a programmer navigates in a browser instrumented with the Tutorons plugin, programmers can view context-relevant explanations of high-level intent of code and its low level syntax for snippets automatically detected by the server.
This was implemented for three languages commonly embedded in tutorials: the wget Unix command line, CSS selectors, and regular expressions.
An initial in-lab usability study has shown that such adaptive explanations can reduce accesses to external documentation on the Web (Fisher's exact test, $n$ = 9, $p<.01$).

\subsection{StackSkim}
It is often the case that there are many tutorials or code examples that can satisfy a programmer's information need, yet the first one programmers find is often not sufficient.
StackSkim is a visual search interface for exploring, comparing, and selecting code and its accompanying explanations from large collections of similar examples.
It currently provides a front-end to the >10,000,000 questions on StackOverflow, a popular programming Q\&A.
It enables programmers to detect the most popular classes and programming structures used in collections of dozens of related answers to their questions, and locate examples with either minimal or elaborate accompanying explanation.
A preliminary usability study revealed positive qualitative feedback, it has yet to be applied to be comprehensively evaluated.
In future versions, we want to address two challenges: 
(1) proper algorithms and visual affordances to highlight differences between competitive snippets
(2) enabling interleaved inspection of instructional examples next to real code that may reveal realistic exceptions
% The primary technical contribution for both of these steps will revolve around comparison of pre-parsed code examples from the relatively clean repositories of example and production code on StackOverflow and Github, respectively.

\subsection{CodeConverter}
When developing opportunistically, programmers have a set of go-to tools they rely on to get work done (Brandt et al. 2008).
This project, our most experimental, seeks to provide methods for enabling programmers to write in a new language in a familiar domain using simple statements of languages they are comfortable with.
Instead of learning a language's syntax through a separate tutorial, relevant feedback will be provided as comments that accompany expansions of code to the target language---that is, documentation will only be provided as programmers first encounter the features.
To maintain feasibility, we will focus on recognizing and translating language for small statements for restricted problem sets, based on rules rather than machine translation (e.g.,~\cite{karaivanov_phrase-based_2014}).
% The eventual evaluation will focus on having programmers from a local hackerspace develop code for an embedded platform with an unfamiliar language but with familiar tasks.

\if 0
\begin{figure}%
  \centering
  \parbox{.45\textwidth}{%
    \includegraphics[width=\linewidth]{figures/tutorons_microexplanation}
    \caption{%
      A micro-explanation for a command line generated by a Tutoron with multiple levels of detail 
      (definition, high-level intent, arguments)
    }\label{fig:tutorons_microexplanation}
  }%
  \qquad
  \parbox{.45\textwidth}{%
    \includegraphics[width=\linewidth]{figures/stackskim_ui}
    \caption{%
      StackSkim, a visual interface for comparing and noticing trends in large collections of code examples that solve the same problem.
    }\label{fig:stackskim_ui}
  }
\end{figure}
\fi

\if 0
Point out the number of non-professional programmers.
Also point out crises in developing technologies that are caused by programmers who followed non-systematic practices

This work can be seen as an effort to reconcile the best practices of the ``systematic developer'' with recent tendencies of ``opportunistic'' programming habits.
\textbf{I could add in a mention of Blackwell's Attention Investment model here to mention why it is that programmers may program opportunistically, and why we should and how we can vary incentives and costs.}
Clarke~\cite{clarke_what_2007} introduced the persona of an \emph{opportunistic developer} to describe a software developer who writes code in an ``exploratory fashion'' and develops a ``sufficient understanding of a technology to understand how it can solve a business problem''.
(This contrasts with the \emph{systematic developer}, who writes code defensively and ``develops a deep understanding of a technology before using it''~\cite{clarke_what_2007}.)
In their study of exhibit designers at San Francisco's Exploratorium interactive science museum, Brandt et al.\ reported on a group who engaged in \emph{opportunistic programming} who weren't professional developers~\cite{brandt_opportunistic_2008} but were very much what might be considered as end-user programmers --- those developing code for personal rather than public use~\cite{ko_state_2011}.

Brandt et al.\ associated several habits with opportunistic programming that are counter to what we would hope for students working with code or end-users developing a better understanding of code.
Those programming opportunistically likely to incorporate functionality by copying and pasting code, often from online sources~\cite{brandt_two_2009}.
They are more likely to implement functionality from scratch for well-known libraries, instead of reusing existing systems and libraries~\cite{brandt_opportunistic_2008}.
They also practice ``code satisficing'', implementing functionality in a sub-optimal way in order to maintain flow and move on to other functionality~\cite{brandt_opportunistic_2008}.

While opportunistic programming is powerful in that it allows one to rapidly prototype and ideate and that it reduces the cycle time of editing and debugging code~\cite{brandt_opportunistic_2008}, this behavior discourages the formation of new mental models and an introduction to new tools that should be encouraged for both novice programmers and many end-user programmers.
The author of this proposal observed much of what would be called ``opportunistic'' habits while instructing a user interface design course.
After providing reference code to students for programming interfaces on Android phones and smartwatches, he helped students debug problems related to API reuse and the side effects of mixed code from multiple examples after hearing students self-report to having ``copied and pasted'' code from online tutorials and the slides he distributed.
In light of a prevalence of the ease of opportunistic habits and programmers' ability to copy-and-paste code from an increasingly comprehensive body of crowd documentation online~\cite{parnin_crowd_2012}, I define the goals of my research:

\emph{In my research, I develop and study software artifacts to support systematic inspection of found code from information interfaces programmers use when developing opportunistically.}

The theoretical deliverables of this work is establishing how systematic habits amidst opportunistic practice will improve:
(\emph{a}) programmers' mental models of reused code, libraries and tools used they develop
(\emph{b}) enable more accurate feasibility assessments of upcoming tasks (for example, see~\cite{ko_role_2011})
(\emph{c}) reduce design barriers~\cite{ko_six_2004} when planning new functionality

The artifacts that I develop belong to two themes:
\begin{itemize}[noitemsep]
\item Techniques for automatically generating instructive explanations and demonstrations of found code
\item Interfaces for critical inspection of alternatives when selecting code for reuse
\end{itemize}

I have developed the artifacts that enable exploration within both of these themes, and have published a first paper on the one of the two themes.
Toward the first, a paper I presented at VL/HCC explored techniques for automatically augmenting code in online examples with natural languages explanations and demonstrations of code.\footnote{%
The Tutorons system was implemented as both a browser plugin and a standalone JavaScript library, and can be viewed in action on \url{www.tutorons.com}.
}
We put forward a set of four guidelines to inspire the development of context-sensitive help:
(\emph{a}) leverage multiple representations to illuminate high-level intent and enable low-level understanding of syntax
(\emph{b}) be concise --- skip static explanations and focus on dynamically generated content
(\emph{c}) reappropriate existing documentation
(\emph{d}) inspect code examples on a large scale to support explanations of common usage.
In a nine-participant user study, the system was shown to reduce the number of accesses to external documentation needed to modify online code to perform new tasks.
\textbf{Next steps will include \ldots}
\textbf{Mention the theories used: MLT, layered documentation, Attention Investment}

Towards the second goal, I and co-developer have built a visual search interface for StackOverflow, a popular online programming Q\&A.
In response to Brandt et al.'s recommendations to develop tools that support ``comparing, reasoning about, integrating, and modifying found code''~\cite{brandt_opportunistic_2008}, we developed StackSkim, \emph{a visual search interface for exploring answers to StackOverflow questions that have a multitude of answers}.
The interface offers rapid visual inspection of frequent libraries used for addressing the searcher's programming problem;
through direct manipulation, users can also rapidly collect and compare similar code snippets.
\textbf{Next steps will include \ldots}

Each of these efforts relies on the cultivation of new software artifacts to aid programmers in understanding code during an opportunistic programming task.
Each has already followed and will continue to follow a mixed methods approach of observation and controlled experiments to determine how these tools indeed alter not only the task of opportunistic programming, but also programmers' behavior in selecting, understanding, and using code found online.
We are currently developing a version of Tutorons explanations that we hope will be incorporated into an introductory CS classroom's online textbook to better understand the role of automatic explanations of code for novice programmers.
\textbf{Add some note here about how we intend to run some workshop on clean code reuse habits.}
\fi

\section{References}
\printbibliography[heading=none]

\end{document}
